<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>YOLOv8 TF.js iPhone Demo</title>
<style>
  body { margin: 0; overflow: hidden; font-family: sans-serif; }
  video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
</style>
</head>
<body>

<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>

<script type="module">
import * as tf from 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js';

// YOLOv8n TF.js 模型 CDN
const MODEL_URL = 'https://huggingface.co/ultralytics/yolov8n-tfjs/resolve/main/model.json';
const model = await tf.loadGraphModel(MODEL_URL);

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// 打开手机摄像头
async function setupCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' }, // 后置摄像头
        audio: false
    });
    video.srcObject = stream;
    return new Promise(resolve => {
        video.onloadedmetadata = () => {
            video.play();
            resolve(video);
        };
    });
}

// YOLO 推理
async function detectFrame() {
    if (video.readyState < 2) {
        requestAnimationFrame(detectFrame);
        return;
    }

    const input = tf.browser.fromPixels(video).expandDims(0).toFloat().div(255);
    const predictions = await model.executeAsync(input);

    // 假设模型输出 boxes, scores, classes
    const boxes = predictions[0].arraySync();
    const scores = predictions[1].arraySync();
    const classes = predictions[2].arraySync();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    for (let i = 0; i < scores.length; i++) {
        if (scores[i] > 0.3) { // 阈值可调
            const [y1, x1, y2, x2] = boxes[i];
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(x1 * canvas.width, y1 * canvas.height,
                           (x2 - x1) * canvas.width, (y2 - y1) * canvas.height);
            ctx.fillStyle = 'red';
            ctx.font = '16px sans-serif';
            ctx.fillText(classes[i] + ' ' + (scores[i]*100).toFixed(1)+'%',
                         x1 * canvas.width, y1 * canvas.height > 20 ? y1 * canvas.height - 5 : 10);
        }
    }

    tf.dispose([input, ...predictions]);
    requestAnimationFrame(detectFrame);
}

await setupCamera();
detectFrame();
</script>

</body>
</html>
