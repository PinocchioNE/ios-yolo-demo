<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YOLOv8 TF.js Demo - Fixed</title>
  <style>
    video, canvas { border: 1px solid black; }
    .container { display: flex; gap: 20px; }
    .controls { margin: 10px 0; }
    .debug { margin: 10px 0; font-family: monospace; font-size: 12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
</head>
<body>
  <h2>YOLOv8 TF.js Demo - Fixed Version</h2>
  <div class="controls">
    <button id="switchBtn">切换摄像头</button>
    <span>置信度阈值: <input type="range" id="confSlider" min="0.01" max="0.9" step="0.01" value="0.25"> <span id="confValue">0.25</span></span>
  </div>
  <div class="container">
    <video id="video" autoplay playsinline width="640" height="480"></video>
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>
  <div id="status">加载中...</div>
  <div class="debug" id="debug">调试信息将显示在这里</div>

  <script>
    // COCO数据集类别名称
    const classNames = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
      'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
      'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
      'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    let confThreshold = 0.25;
    const iouThreshold = 0.45;

    window.onload = async () => {
      let model;
      let video = document.getElementById('video');
      let canvas = document.getElementById('canvas');
      let ctx = canvas.getContext('2d');
      let useFrontCamera = false;
      let currentStream;
      let isDetecting = false;
      
      const statusDiv = document.getElementById('status');
      const debugDiv = document.getElementById('debug');
      const confSlider = document.getElementById('confSlider');
      const confValue = document.getElementById('confValue');

      function updateDebug(message) {
        debugDiv.textContent = message;
        console.log(message);
      }

      // 置信度滑块事件
      confSlider.addEventListener('input', (e) => {
        confThreshold = parseFloat(e.target.value);
        confValue.textContent = confThreshold.toFixed(2);
      });

      // 加载模型
      async function loadModel() {
        try {
          statusDiv.textContent = '正在加载模型...';
          model = await tf.loadGraphModel('https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json');
          console.log('模型加载完成');
          statusDiv.textContent = '模型加载完成，正在启动摄像头...';
        } catch (error) {
          console.error('模型加载失败:', error);
          statusDiv.textContent = '模型加载失败: ' + error.message;
        }
      }

      // 启动摄像头
      async function startCamera() {
        try {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }
          
          const constraints = {
            audio: false,
            video: {
              facingMode: useFrontCamera ? 'user' : 'environment',
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          };
          
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = currentStream;

          video.onloadedmetadata = () => {
            video.play();
            statusDiv.textContent = '检测中...';
            if (model && !isDetecting) {
              detectFrame();
            }
          };
        } catch (error) {
          console.error('摄像头启动失败:', error);
          statusDiv.textContent = '摄像头启动失败: ' + error.message;
        }
      }

      // 切换摄像头
      document.getElementById('switchBtn').addEventListener('click', () => {
        useFrontCamera = !useFrontCamera;
        startCamera();
      });

      // 绘制检测框
      function drawBoxes(boxes) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        updateDebug(`检测到 ${boxes.length} 个对象`);
        
        boxes.forEach(box => {
          const [x1, y1, x2, y2, score, classId] = box;
          const className = classNames[classId] || `Class ${classId}`;
          
          // 绘制边框
          ctx.strokeStyle = '#FF0000';
          ctx.lineWidth = 2;
          ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
          
          // 绘制标签背景
          const label = `${className} ${(score * 100).toFixed(1)}%`;
          ctx.font = '14px Arial';
          const textWidth = ctx.measureText(label).width;
          const textHeight = 20;
          
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(x1, y1 - textHeight, textWidth + 8, textHeight);
          
          // 绘制标签文字
          ctx.fillStyle = '#FFFFFF';
          ctx.fillText(label, x1 + 4, y1 - 6);
        });
      }

      // 修复后的输出处理函数
      async function processOutput(predictions) {
        try {
          let output = predictions;
          
          // 如果输出是 [1, 84, 8400] 格式，转换为 [1, 8400, 84]
          if (output.shape.length === 3 && output.shape[1] === 84) {
            output = output.transpose([0, 2, 1]);
          }
          
          const data = await output.data();
          const numDetections = output.shape[1]; // 8400
          
          const boxes = [];
          const scores = [];
          const classIds = [];
          
          let validDetections = 0;
          let maxConfidence = 0;
          
          // 解析每个检测结果
          for (let i = 0; i < numDetections; i++) {
            const offset = i * 84;
            
            // YOLOv8输出格式：[x_center, y_center, width, height, class0_prob, class1_prob, ...]
            const centerX = data[offset];
            const centerY = data[offset + 1];
            const width = data[offset + 2];
            const height = data[offset + 3];
            
            // 获取所有类别概率（从索引4开始的80个类别）
            const classProbs = [];
            for (let j = 4; j < 84; j++) {
              classProbs.push(data[offset + j]);
            }
            
            // 找到最高概率的类别
            const maxClassProb = Math.max(...classProbs);
            const classId = classProbs.indexOf(maxClassProb);
            
            // YOLOv8直接输出类别概率，不需要乘以objectness
            const confidence = maxClassProb;
            
            if (confidence > maxConfidence) {
              maxConfidence = confidence;
            }
            
            // 使用更低的阈值进行初步筛选
            if (confidence > 0.1) {
              validDetections++;
              
              if (confidence > confThreshold) {
                // 转换坐标到画布尺寸
                const x1 = Math.max(0, (centerX - width / 2) * canvas.width);
                const y1 = Math.max(0, (centerY - height / 2) * canvas.height);
                const x2 = Math.min(canvas.width, (centerX + width / 2) * canvas.width);
                const y2 = Math.min(canvas.height, (centerY + height / 2) * canvas.height);
                
                boxes.push([y1, x1, y2, x2]); // NMS需要[y1,x1,y2,x2]格式
                scores.push(confidence);
                classIds.push(classId);
              }
            }
          }
          
          console.log(`有效检测: ${validDetections}, 最高置信度: ${maxConfidence.toFixed(3)}, 通过阈值: ${boxes.length}`);
          
          if (boxes.length === 0) {
            return [];
          }
          
          // 应用非极大值抑制
          const boxesTensor = tf.tensor2d(boxes);
          const scoresTensor = tf.tensor1d(scores);
          
          const selectedIndices = await tf.image.nonMaxSuppressionAsync(
            boxesTensor,
            scoresTensor,
            50,
            iouThreshold,
            confThreshold
          );
          
          const selectedIndicesArray = await selectedIndices.data();
          
          // 构建最终结果
          const finalBoxes = [];
          for (let i = 0; i < selectedIndicesArray.length; i++) {
            const idx = selectedIndicesArray[i];
            const box = boxes[idx];
            finalBoxes.push([
              box[1], // x1
              box[0], // y1
              box[3], // x2
              box[2], // y2
              scores[idx],
              classIds[idx]
            ]);
          }
          
          // 清理张量
          boxesTensor.dispose();
          scoresTensor.dispose();
          selectedIndices.dispose();
          
          return finalBoxes;
          
        } catch (error) {
          console.error('处理输出时出错:', error);
          return [];
        }
      }

      // 检测帧
      async function detectFrame() {
        if (!model || !video.videoWidth || isDetecting) {
          requestAnimationFrame(detectFrame);
          return;
        }
        
        isDetecting = true;
        
        try {
          // 使用 tf.tidy 管理内存
          const result = tf.tidy(() => {
            const input = tf.browser.fromPixels(video)
              .resizeBilinear([640, 640])
              .expandDims(0)
              .toFloat()
              .div(255.0);
            return input;
          });
          
          // 使用 execute 而不是 executeAsync（根据警告建议）
          const predictions = model.execute(result);
          
          // 处理输出
          const boxes = await processOutput(predictions);
          
          // 绘制结果
          drawBoxes(boxes);
          
          // 清理张量
          result.dispose();
          if (Array.isArray(predictions)) {
            predictions.forEach(p => p.dispose());
          } else {
            predictions.dispose();
          }
          
        } catch (error) {
          console.error('检测过程中出错:', error);
          updateDebug('检测出错: ' + error.message);
        }
        
        isDetecting = false;
        requestAnimationFrame(detectFrame);
      }

      // 初始化
      try {
        await loadModel();
        await startCamera();
      } catch (error) {
        console.error('初始化失败:', error);
        statusDiv.textContent = '初始化失败: ' + error.message;
      }
    };
  </script>
</body>
</html>
