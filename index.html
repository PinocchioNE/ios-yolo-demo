<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>YOLOv8-tfjs Demo</title>
    <!-- 保留你之前的 tf.min.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
</head>
<body>
<video id="video" width="640" height="480" autoplay muted></video>
<canvas id="canvas" width="640" height="480"></canvas>

<script>
async function setupCamera() {
    const video = document.getElementById('video');
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    return new Promise(resolve => {
        video.onloadedmetadata = () => { resolve(video); };
    });
}

function xywh2xyxy(box){
    const [x, y, w, h] = box;
    return [x - w/2, y - h/2, x + w/2, y + h/2];
}

// 简单 NMS
function nonMaxSuppression(boxes, scores, iouThreshold=0.45) {
    const picked = [];
    const indexes = scores.map((s,i)=>[s,i]).sort((a,b)=>b[0]-a[0]).map(a=>a[1]);
    while(indexes.length>0){
        const i = indexes.shift();
        picked.push(i);
        const a = boxes[i];
        indexes = indexes.filter(j=>{
            const b = boxes[j];
            const xx1 = Math.max(a[0], b[0]);
            const yy1 = Math.max(a[1], b[1]);
            const xx2 = Math.min(a[2], b[2]);
            const yy2 = Math.min(a[3], b[3]);
            const w = Math.max(0, xx2-xx1);
            const h = Math.max(0, yy2-yy1);
            const inter = w*h;
            const union = (a[2]-a[0])*(a[3]-a[1]) + (b[2]-b[0])*(b[3]-b[1]) - inter;
            const iou = inter/union;
            return iou < iouThreshold;
        });
    }
    return picked;
}

// COCO 类名列表（对应 yolov8n 默认训练）
const COCO_CLASSES = [
    "person","bicycle","car","motorcycle","airplane","bus","train","truck",
    "boat","traffic light","fire hydrant","stop sign","parking meter","bench",
    "bird","cat","dog","horse","sheep","cow","elephant","bear","zebra",
    "giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee",
    "skis","snowboard","sports ball","kite","baseball bat","baseball glove",
    "skateboard","surfboard","tennis racket","bottle","wine glass","cup",
    "fork","knife","spoon","bowl","banana","apple","sandwich","orange",
    "broccoli","carrot","hot dog","pizza","donut","cake","chair","couch",
    "potted plant","bed","dining table","toilet","tv","laptop","mouse",
    "remote","keyboard","cell phone","microwave","oven","toaster","sink",
    "refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"
];

async function run() {
    const video = await setupCamera();
    video.play();

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 使用你之前的 model 路径
    const model = await tf.loadGraphModel('https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json');

    const confThreshold = 0.25;

    async function detectFrame() {
        tf.engine().startScope();

        let input = tf.browser.fromPixels(video)
            .resizeBilinear([640,640])
            .div(255.0)
            .expandDims(0); // [1,640,640,3]

        const pred = await model.executeAsync(input); 
        // 输出 shape: [1,num_boxes,85]，85=4+1+80
        const data = pred.arraySync()[0]; // [num_boxes,85]

        const boxes = [];
        const scores = [];
        const classes = [];

        data.forEach(d=>{
            const objScore = d[4];
            const classProbs = d.slice(5);
            const classId = classProbs.indexOf(Math.max(...classProbs));
            const score = objScore * classProbs[classId];
            if(score>confThreshold){
                const box = xywh2xyxy(d.slice(0,4));
                boxes.push(box);
                scores.push(score);
                classes.push(classId);
            }
        });

        const picked = nonMaxSuppression(boxes, scores, 0.45);

        ctx.drawImage(video,0,0,canvas.width,canvas.height);

        picked.forEach(i=>{
            const [x1,y1,x2,y2] = boxes[i];
            ctx.strokeStyle='red';
            ctx.lineWidth=2;
            ctx.strokeRect(x1*canvas.width/640, y1*canvas.height/640,
                           (x2-x1)*canvas.width/640, (y2-y1)*canvas.height/640);
            ctx.fillStyle='red';
            ctx.font='18px Arial';
            ctx.fillText(`${COCO_CLASSES[classes[i]]} ${scores[i].toFixed(2)}`, 
                         x1*canvas.width/640, y1*canvas.height/640-5);
        });

        tf.dispose([input, pred]);
        requestAnimationFrame(detectFrame);
        tf.engine().endScope();
    }

    detectFrame();
}

run();
</script>
</body>
</html>
