<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 TensorFlow.js 实时检测</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .video-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }
        #videoElement {
            border: 2px solid #333;
            border-radius: 8px;
            max-width: 100%;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border: 2px solid transparent;
            border-radius: 8px;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status.ready {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .setting-group {
            display: flex;
            flex-direction: column;
        }
        .setting-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        .setting-group input, .setting-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .detection-info {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>YOLOv8 TensorFlow.js 实时目标检测</h1>
        
        <div class="status loading" id="status">正在初始化...</div>
        
        <div class="controls">
            <button id="startBtn" class="btn-primary">开始检测</button>
            <button id="stopBtn" class="btn-secondary" disabled>停止检测</button>
            <button id="captureBtn" class="btn-secondary" disabled>截图</button>
            <button id="downloadBtn" class="btn-secondary" disabled>下载模型信息</button>
        </div>
        
        <div class="settings">
            <div class="setting-group">
                <label for="confidenceThreshold">置信度阈值:</label>
                <input type="range" id="confidenceThreshold" min="0.1" max="0.9" step="0.05" value="0.3">
                <span id="confidenceValue">0.30</span>
            </div>
            <div class="setting-group">
                <label for="iouThreshold">IoU阈值:</label>
                <input type="range" id="iouThreshold" min="0.1" max="0.9" step="0.05" value="0.45">
                <span id="iouValue">0.45</span>
            </div>
            <div class="setting-group">
                <label for="maxDetections">最大检测数:</label>
                <input type="number" id="maxDetections" min="1" max="50" value="10">
            </div>
            <div class="setting-group">
                <label for="showTopK">显示前K个预测:</label>
                <input type="number" id="showTopK" min="1" max="5" value="1">
            </div>
        </div>
        
        <div class="video-container">
            <video id="videoElement" width="640" height="480" autoplay muted playsinline></video>
            <canvas id="canvas" width="640" height="480"></canvas>
            <div class="fps-counter" id="fpsCounter">FPS: 0</div>
        </div>
        
        <div class="detection-info" id="detectionInfo">
            <strong>检测信息:</strong><br>
            等待开始检测...
        </div>
    </div>

    <script>
        // COCO数据集类别名称
        const classNames = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        // 全局变量
        let model = null;
        let video = null;
        let canvas = null;
        let ctx = null;
        let isDetecting = false;
        let animationId = null;
        let detectionHistory = [];
        const historyLength = 5;
        
        // FPS计算
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        
        // 检测统计
        let totalDetections = 0;
        let detectionStats = {};

        // 初始化
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeApp();
        });

        async function initializeApp() {
            try {
                updateStatus('正在初始化摄像头...', 'loading');
                await setupCamera();
                
                updateStatus('正在加载YOLOv8模型...', 'loading');
                await loadModel();
                
                setupEventListeners();
                updateStatus('初始化完成，点击"开始检测"开始', 'ready');
                
                document.getElementById('startBtn').disabled = false;
            } catch (error) {
                console.error('初始化失败:', error);
                updateStatus(`初始化失败: ${error.message}`, 'error');
            }
        }

        async function setupCamera() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // 针对iPhone 14 Pro优化的摄像头设置
            const constraints = {
                video: {
                    width: { ideal: 1280, max: 1920 },
                    height: { ideal: 720, max: 1080 },
                    frameRate: { ideal: 30, max: 60 },
                    facingMode: 'environment', // 后置摄像头
                    focusMode: 'continuous'
                }
            };
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        // 调整canvas尺寸匹配视频
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        video.width = video.videoWidth;
                        video.height = video.videoHeight;
                        
                        console.log(`摄像头分辨率: ${video.videoWidth}x${video.videoHeight}`);
                        resolve();
                    };
                });
            } catch (error) {
                throw new Error(`摄像头访问失败: ${error.message}`);
            }
        }

        async function loadModel() {
            try {
                // 使用YOLOv8n模型URL（你需要替换为实际的模型URL）
                const modelUrl = 'https://your-model-url/yolov8n_web_model/model.json';
                
                // 或者使用本地模型路径
                // const modelUrl = './models/yolov8n/model.json';
                
                model = await tf.loadLayersModel(modelUrl);
                
                // 预热模型
                const dummyInput = tf.zeros([1, 640, 640, 3]);
                const warmupResult = model.predict(dummyInput);
                warmupResult.dispose();
                dummyInput.dispose();
                
                console.log('模型加载成功');
                console.log('模型输入形状:', model.inputs[0].shape);
                console.log('模型输出形状:', model.outputs[0].shape);
                
            } catch (error) {
                throw new Error(`模型加载失败: ${error.message}`);
            }
        }

        function setupEventListeners() {
            document.getElementById('startBtn').addEventListener('click', startDetection);
            document.getElementById('stopBtn').addEventListener('click', stopDetection);
            document.getElementById('captureBtn').addEventListener('click', captureFrame);
            document.getElementById('downloadBtn').addEventListener('click', downloadModelInfo);
            
            // 设置参数监听
            const confidenceSlider = document.getElementById('confidenceThreshold');
            const iouSlider = document.getElementById('iouThreshold');
            
            confidenceSlider.addEventListener('input', (e) => {
                document.getElementById('confidenceValue').textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            iouSlider.addEventListener('input', (e) => {
                document.getElementById('iouValue').textContent = parseFloat(e.target.value).toFixed(2);
            });
        }

        async function startDetection() {
            if (!model || !video) {
                updateStatus('模型或摄像头未准备好', 'error');
                return;
            }
            
            isDetecting = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('captureBtn').disabled = false;
            
            updateStatus('正在检测中...', 'ready');
            
            // 重置统计
            totalDetections = 0;
            detectionStats = {};
            lastTime = performance.now();
            frameCount = 0;
            
            detectLoop();
        }

        function stopDetection() {
            isDetecting = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('captureBtn').disabled = true;
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateStatus('检测已停止', 'ready');
            updateDetectionInfo('检测已停止');
        }

        async function detectLoop() {
            if (!isDetecting) return;
            
            try {
                const startTime = performance.now();
                
                // 执行检测
                const detections = await runDetection();
                
                // 绘制结果
                drawDetections(detections);
                
                // 更新信息
                updateDetectionInfo(detections);
                
                // 计算FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastTime = currentTime;
                }
                
                const processingTime = performance.now() - startTime;
                console.log(`处理时间: ${processingTime.toFixed(2)}ms`);
                
            } catch (error) {
                console.error('检测错误:', error);
                updateStatus(`检测错误: ${error.message}`, 'error');
            }
            
            animationId = requestAnimationFrame(detectLoop);
        }

        async function runDetection() {
            // 预处理输入图像
            const inputTensor = tf.tidy(() => {
                // 从视频获取图像数据
                const videoTensor = tf.browser.fromPixels(video);
                
                // 调整大小到640x640
                const resized = tf.image.resizeBilinear(videoTensor, [640, 640]);
                
                // 归一化到[0,1]
                const normalized = resized.div(255.0);
                
                // 添加batch维度
                const batched = normalized.expandDims(0);
                
                return batched;
            });
            
            // 模型推理
            const predictions = model.predict(inputTensor);
            
            // 处理输出
            const detections = await processModelOutput(predictions);
            
            // 清理内存
            inputTensor.dispose();
            if (Array.isArray(predictions)) {
                predictions.forEach(tensor => tensor.dispose());
            } else {
                predictions.dispose();
            }
            
            return detections;
        }

        async function processModelOutput(predictions) {
            const confidenceThreshold = parseFloat(document.getElementById('confidenceThreshold').value);
            const iouThreshold = parseFloat(document.getElementById('iouThreshold').value);
            const maxDetections = parseInt(document.getElementById('maxDetections').value);
            
            // 获取预测数据
            const predictionData = await predictions.data();
            const shape = predictions.shape;
            
            console.log('原始输出形状:', shape);
            console.log('原始输出数据长度:', predictionData.length);
            
            const detections = [];
            
            // YOLOv8输出格式: [batch, 84, 8400] 或 [batch, 8400, 84]
            // 84 = 4(bbox) + 80(classes)
            let numDetections, numClasses;
            
            if (shape.length === 3) {
                if (shape[1] === 84) {
                    // [1, 84, 8400] 格式
                    numDetections = shape[2];
                    numClasses = shape[1] - 4;
                } else {
                    // [1, 8400, 84] 格式
                    numDetections = shape[1];
                    numClasses = shape[2] - 4;
                }
            } else {
                console.error('未知的输出形状:', shape);
                return [];
            }
            
            console.log(`检测数量: ${numDetections}, 类别数量: ${numClasses}`);
            
            // 解析检测结果
            for (let i = 0; i < numDetections; i++) {
                let x, y, w, h;
                let classProbs = [];
                
                if (shape[1] === 84) {
                    // [1, 84, 8400] 格式
                    x = predictionData[i];
                    y = predictionData[numDetections + i];
                    w = predictionData[2 * numDetections + i];
                    h = predictionData[3 * numDetections + i];
                    
                    for (let j = 0; j < numClasses; j++) {
                        classProbs.push(predictionData[(4 + j) * numDetections + i]);
                    }
                } else {
                    // [1, 8400, 84] 格式
                    const offset = i * 84;
                    x = predictionData[offset];
                    y = predictionData[offset + 1];
                    w = predictionData[offset + 2];
                    h = predictionData[offset + 3];
                    
                    for (let j = 0; j < numClasses; j++) {
                        classProbs.push(predictionData[offset + 4 + j]);
                    }
                }
                
                // 找到最高置信度的类别
                const maxConfidence = Math.max(...classProbs);
                const classIndex = classProbs.indexOf(maxConfidence);
                
                if (maxConfidence > confidenceThreshold) {
                    // 转换坐标 (中心点格式到左上角格式)
                    const x1 = (x - w / 2) * canvas.width / 640;
                    const y1 = (y - h / 2) * canvas.height / 640;
                    const width = w * canvas.width / 640;
                    const height = h * canvas.height / 640;
                    
                    detections.push({
                        bbox: [x1, y1, width, height],
                        class: classIndex,
                        className: classNames[classIndex] || `class_${classIndex}`,
                        confidence: maxConfidence,
                        allProbs: classProbs
                    });
                }
            }
            
            console.log(`初步筛选后检测数量: ${detections.length}`);
            
            // 应用NMS (非极大值抑制)
            const nmsDetections = applyNMS(detections, iouThreshold);
            
            // 限制最大检测数量
            const finalDetections = nmsDetections
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, maxDetections);
            
            console.log(`最终检测数量: ${finalDetections.length}`);
            
            return finalDetections;
        }

        function applyNMS(detections, iouThreshold) {
            if (detections.length === 0) return [];
            
            // 按置信度排序
            detections.sort((a, b) => b.confidence - a.confidence);
            
            const keep = [];
            const suppressed = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;
                
                keep.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;
                    
                    const iou = calculateIoU(detections[i].bbox, detections[j].bbox);
                    if (iou > iouThreshold && detections[i].class === detections[j].class) {
                        suppressed.add(j);
                    }
                }
            }
            
            return keep;
        }

        function calculateIoU(box1, box2) {
            const [x1_1, y1_1, w1, h1] = box1;
            const [x1_2, y1_2, w2, h2] = box2;
            
            const x2_1 = x1_1 + w1;
            const y2_1 = y1_1 + h1;
            const x2_2 = x1_2 + w2;
            const y2_2 = y1_2 + h2;
            
            const xA = Math.max(x1_1, x1_2);
            const yA = Math.max(y1_1, y1_2);
            const xB = Math.min(x2_1, x2_2);
            const yB = Math.min(y2_1, y2_2);
            
            const interArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
            const box1Area = w1 * h1;
            const box2Area = w2 * h2;
            const unionArea = box1Area + box2Area - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        function drawDetections(detections) {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (detections.length === 0) return;
            
            const showTopK = parseInt(document.getElementById('showTopK').value);
            
            detections.forEach((detection, index) => {
                const [x, y, width, height] = detection.bbox;
                const className = detection.className;
                const confidence = detection.confidence;
                
                // 绘制边界框
                ctx.strokeStyle = getClassColor(detection.class);
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);
                
                // 绘制标签背景
                const label = `${className} ${(confidence * 100).toFixed(1)}%`;
                ctx.font = '16px Arial';
                const textWidth = ctx.measureText(label).width;
                const textHeight = 20;
                
                ctx.fillStyle = getClassColor(detection.class);
                ctx.fillRect(x, y - textHeight - 5, textWidth + 10, textHeight + 5);
                
                // 绘制标签文字
                ctx.fillStyle = 'white';
                ctx.fillText(label, x + 5, y - 8);
                
                // 显示多个预测结果
                if (showTopK > 1) {
                    const topPredictions = getTopPredictions(detection.allProbs, showTopK);
                    topPredictions.forEach((pred, idx) => {
                        if (idx > 0) { // 跳过第一个（已经显示）
                            const subLabel = `${pred.class} ${(pred.confidence * 100).toFixed(1)}%`;
                            ctx.fillStyle = 'rgba(0,0,0,0.7)';
                            ctx.fillRect(x, y + height + idx * 20, ctx.measureText(subLabel).width + 10, 18);
                            ctx.fillStyle = 'white';
                            ctx.fillText(subLabel, x + 5, y + height + idx * 20 + 14);
                        }
                    });
                }
            });
        }

        function getTopPredictions(classProbs, topK = 3) {
            const predictions = classProbs.map((prob, index) => ({
                class: classNames[index] || `class_${index}`,
                confidence: prob,
                index: index
            })).sort((a, b) => b.confidence - a.confidence);
            
            return predictions.slice(0, topK);
        }

        function getClassColor(classIndex) {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#F4D03F'
            ];
            return colors[classIndex % colors.length];
        }

        function updateDetectionInfo(detections) {
            const infoElement = document.getElementById('detectionInfo');
            
            if (typeof detections === 'string') {
                infoElement.innerHTML = `<strong>状态:</strong> ${detections}`;
                return;
            }
            
            if (!detections || detections.length === 0) {
                infoElement.innerHTML = `
                    <strong>检测信息:</strong><br>
                    当前帧: 无检测结果<br>
                    总检测数: ${totalDetections}<br>
                    FPS: ${fps}
                `;
                return;
            }
            
            // 更新统计
            totalDetections += detections.length;
            detections.forEach(det => {
                detectionStats[det.className] = (detectionStats[det.className] || 0) + 1;
            });
            
            // 显示当前检测结果
            let info = `<strong>检测信息:</strong><br>`;
            info += `当前帧检测数: ${detections.length}<br>`;
            info += `总检测数: ${totalDetections}<br>`;
            info += `FPS: ${fps}<br><br>`;
            
            info += `<strong>当前检测:</strong><br>`;
            detections.forEach((det, idx) => {
                info += `${idx + 1}. ${det.className}: ${(det.confidence * 100).toFixed(1)}%<br>`;
            });
            
            info += `<br><strong>检测统计:</strong><br>`;
            Object.entries(detectionStats)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .forEach(([className, count]) => {
                    info += `${className}: ${count}次<br>`;
                });
            
            infoElement.innerHTML = info;
        }

        function updateStatus(message, type = 'loading') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        function captureFrame() {
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            
            captureCanvas.width = canvas.width;
            captureCanvas.height = canvas.height;
            
            // 绘制视频帧
            captureCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // 绘制检测结果
            captureCtx.drawImage(canvas, 0, 0);
            
            // 下载图片
            const link = document.createElement('a');
            link.download = `detection_${new Date().getTime()}.png`;
            link.href = captureCanvas.toDataURL();
            link.click();
        }

        function downloadModelInfo() {
            const info = {
                modelInfo: {
                    inputs: model.inputs.map(input => ({
                        name: input.name,
                        shape: input.shape,
                        dtype: input.dtype
                    })),
                    outputs: model.outputs.map(output => ({
                        name: output.name,
                        shape: output.shape,
                        dtype: output.dtype
                    }))
                },
                detectionStats: detectionStats,
                totalDetections: totalDetections,
                classNames: classNames,
                settings: {
                    confidenceThreshold: document.getElementById('confidenceThreshold').value,
                    iouThreshold: document.getElementById('iouThreshold').value,
                    maxDetections: document.getElementById('maxDetections').value
                }
            };
            
            const blob = new Blob([JSON.stringify(info, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `model_info_${new Date().getTime()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // 错误处理
        window.addEventListener('error', (event) => {
            console.error('全局错误:', event.error);
            updateStatus(`发生错误: ${event.error.message}`, 'error');
        });

        // 内存监控
        setInterval(() => {
            if (tf && tf.memory) {
                const memInfo = tf.memory();
                console.log('TensorFlow.js 内存使用:', memInfo);
                
                // 如果内存使用过高，触发垃圾回收
                if (memInfo.numTensors > 100) {
                    console.warn('张量数量过多，触发垃圾回收');
                    tf.dispose();
                }
            }
        }, 10000); // 每10秒检查一次

    </script>
</body>
</html>
