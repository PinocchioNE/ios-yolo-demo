<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 TensorFlow.js 目标检测</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .video-wrapper {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        #videoElement {
            width: 480px;
            height: 360px;
            object-fit: cover;
        }
        #outputCanvas {
            width: 480px;
            height: 360px;
            border: 2px solid #007bff;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-card h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }
        .info-card p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .detection-details {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
        }
        .detection-details h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }
        .status.ready {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>YOLOv8 TensorFlow.js 实时目标检测</h1>
            <div id="status" class="status loading">正在初始化...</div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">开始检测</button>
            <button id="stopBtn" class="btn-secondary" disabled>停止检测</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="videoElement" autoplay muted playsinline></video>
                <div style="text-align: center; margin-top: 10px;">摄像头输入</div>
            </div>
            <div class="video-wrapper">
                <canvas id="outputCanvas"></canvas>
                <div style="text-align: center; margin-top: 10px;">检测结果</div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h3>模型状态:</h3>
                <p id="modelStatus">未加载</p>
            </div>
            <div class="info-card">
                <h3>检测FPS:</h3>
                <p id="fpsDisplay">0</p>
            </div>
            <div class="info-card">
                <h3>处理时间:</h3>
                <p id="processingTime">0ms</p>
            </div>
            <div class="info-card">
                <h3>检测到的对象:</h3>
                <p id="objectCount">0</p>
            </div>
        </div>

        <div class="detection-details">
            <h3>检测详情:</h3>
            <div id="detectionList">暂无检测结果</div>
        </div>
    </div>

    <script>
        let model = null;
        let isDetecting = false;
        let video, canvas, ctx;
        let fps = 0;
        let frameCount = 0;
        let lastTime = performance.now();

        // COCO类别名称
        const classNames = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        async function init() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('outputCanvas');
            ctx = canvas.getContext('2d');

            try {
                updateStatus('正在初始化摄像头...', 'loading');
                await setupCamera();
                await loadModel();
                setupEventListeners();
                updateStatus('初始化完成，点击开始检测', 'ready');
            } catch (error) {
                console.error('初始化失败:', error);
                updateStatus('初始化失败: ' + error.message, 'error');
            }
        }

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                }
            });

            video.srcObject = stream;

            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    // 保持原始比例，不强制640x640
                    canvas.width = 480;
                    canvas.height = 360;
                    resolve();
                };
            });
        }

        async function loadModel() {
            try {
                updateStatus('正在加载YOLO模型...', 'loading');
                document.getElementById('modelStatus').textContent = '加载中...';

                // 替换为你的实际模型URL
                const modelUrl = 'https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json';
                model = await tf.loadGraphModel(modelUrl);

                // 预热模型
                const dummyInput = tf.zeros([1, 640, 640, 3]);
                const warmupResult = model.predict(dummyInput);
                warmupResult.dispose();
                dummyInput.dispose();

                document.getElementById('modelStatus').textContent = '已加载';
                console.log('模型加载成功');
            } catch (error) {
                document.getElementById('modelStatus').textContent = '加载失败';
                throw new Error('模型加载失败: ' + error.message);
            }
        }

        function setupEventListeners() {
            document.getElementById('startBtn').addEventListener('click', startDetection);
            document.getElementById('stopBtn').addEventListener('click', stopDetection);
        }

        function startDetection() {
            if (!model) {
                alert('模型未加载完成');
                return;
            }

            isDetecting = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateStatus('检测中...', 'ready');

            detectLoop();
        }

        function stopDetection() {
            isDetecting = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('检测已停止', 'ready');
        }

        async function detectLoop() {
            if (!isDetecting) return;

            try {
                const startTime = performance.now();

                // 预处理图像
                const inputTensor = preprocessImage();

                // 模型推理
                const predictions = model.predict(inputTensor);

                // 后处理
                const detections = await postprocess(predictions);

                // 绘制结果 - 关键修复点
                drawResults(detections);

                // 更新性能指标
                const processingTime = performance.now() - startTime;
                updatePerformanceMetrics(processingTime, detections.length);

                // 清理内存
                inputTensor.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(tensor => tensor.dispose());
                } else {
                    predictions.dispose();
                }

            } catch (error) {
                console.error('检测过程出错:', error);
            }

            requestAnimationFrame(detectLoop);
        }

        function preprocessImage() {
            // 创建临时canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 640;
            tempCanvas.height = 640;

            // 居中裁剪并缩放到640x640
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const size = Math.min(videoWidth, videoHeight);
            const x = (videoWidth - size) / 2;
            const y = (videoHeight - size) / 2;

            tempCtx.drawImage(video, x, y, size, size, 0, 0, 640, 640);

            // 转换为tensor
            const imageData = tempCtx.getImageData(0, 0, 640, 640);
            return tf.browser.fromPixels(imageData)
                .expandDims(0)
                .div(255.0);
        }

        async function postprocess(predictions) {
            const output = Array.isArray(predictions) ? predictions[0] : predictions;
            const outputData = await output.data();

            const detections = [];
            const numDetections = outputData.length / 85;

            for (let i = 0; i < numDetections; i++) {
                const offset = i * 85;
                const confidence = outputData[offset + 4];

                if (confidence > 0.5) {
                    let maxClassScore = 0;
                    let classId = 0;

                    for (let j = 0; j < 80; j++) {
                        const classScore = outputData[offset + 5 + j];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            classId = j;
                        }
                    }

                    const finalScore = confidence * maxClassScore;

                    if (finalScore > 0.5) {
                        const x = outputData[offset];
                        const y = outputData[offset + 1];
                        const w = outputData[offset + 2];
                        const h = outputData[offset + 3];

                        detections.push({
                            x: x - w / 2,
                            y: y - h / 2,
                            width: w,
                            height: h,
                            confidence: finalScore,
                            classId: classId,
                            className: classNames[classId] || `class_${classId}`
                        });
                    }
                }
            }

            return detections;
        }

        // 关键修复：正确的绘制函数
        function drawResults(detections) {
            // 清空canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制视频帧到canvas，保持原始比例
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 绘制检测框
            detections.forEach((detection) => {
                // 将归一化坐标转换为canvas坐标
                const x = detection.x * canvas.width;
                const y = detection.y * canvas.height;
                const width = detection.width * canvas.width;
                const height = detection.height * canvas.height;

                // 绘制检测框
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);

                // 绘制标签
                const label = `${detection.className} ${(detection.confidence * 100).toFixed(1)}%`;
                ctx.fillStyle = '#FF0000';
                ctx.font = '16px Arial';

                // 标签背景
                const textWidth = ctx.measureText(label).width;
                ctx.fillRect(x, y - 25, textWidth + 10, 25);

                // 标签文字
                ctx.fillStyle = 'white';
                ctx.fillText(label, x + 5, y - 5);
            });

            // 更新检测详情
            updateDetectionDetails(detections);
        }

        function updateDetectionDetails(detections) {
            const detectionList = document.getElementById('detectionList');

            if (detections.length === 0) {
                detectionList.innerHTML = '暂无检测结果';
                return;
            }

            const detectionHTML = detections.map(detection =>
                `${detection.className} (${(detection.confidence * 100).toFixed(1)}%)`
            ).join(', ');

            detectionList.innerHTML = detectionHTML;
        }

        function updatePerformanceMetrics(processingTime, objectCount) {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
            }

            document.getElementById('fpsDisplay').textContent = fps;
            document.getElementById('processingTime').textContent = `${processingTime.toFixed(1)}ms`;
            document.getElementById('objectCount').textContent = objectCount;
        }

        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        // 初始化
        init();
    </script>
</body>
</html>
