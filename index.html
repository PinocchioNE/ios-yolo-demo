<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>YOLOv8 TF.js Demo</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
<style>
  video, canvas { border: 1px solid black; }
  #container { display: flex; gap: 10px; }
</style>
</head>
<body>

<div>
  <button id="switchBtn">切换摄像头</button>
</div>
<div id="container">
  <video id="video" width="640" height="480" autoplay muted></video>
  <canvas id="canvas2" width="640" height="480"></canvas>
</div>

<script>
let model;
let video = document.getElementById('video');
let canvas2 = document.getElementById('canvas2');
let ctx2 = canvas2.getContext('2d');
let currentFacingMode = 'user'; // 前置摄像头

async function loadModel() {
  model = await tf.loadGraphModel('https://hyuto.github.io/yolov8-tfjs/yolov8n_web_model/model.json');
  console.log('Model loaded:', model);
}

async function startVideo() {
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(track => track.stop());
  }
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: currentFacingMode }
  });
  video.srcObject = stream;
}

document.getElementById('switchBtn').addEventListener('click', async () => {
  currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
  await startVideo();
});

async function runDetection() {
  if (!model || !video.srcObject || video.readyState < 2) {
    requestAnimationFrame(runDetection);
    return;
  }

  const input = tf.tidy(() => tf.browser.fromPixels(video)
      .resizeBilinear([640, 640])
      .expandDims(0)
      .div(255));

  const output = await model.executeAsync(input);

  // 打印输出确认结构
  console.log(output);

  let boxes = [];
  // 根据输出 tensor 名称调整
  if (output.output0) {
    const data = await output.output0.array();
    boxes = data[0].map(d => ({
      x1: d[0] * canvas2.width / 640,
      y1: d[1] * canvas2.height / 640,
      x2: d[2] * canvas2.width / 640,
      y2: d[3] * canvas2.height / 640,
      score: d[4],
      class: d[5]
    }));
  }

  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

  boxes.forEach(b => {
    if (b.score > 0.3) {
      ctx2.strokeStyle = 'red';
      ctx2.lineWidth = 2;
      ctx2.strokeRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
      ctx2.fillStyle = 'red';
      ctx2.font = '16px sans-serif';
      ctx2.fillText(`${b.class} ${b.score.toFixed(2)}`, b.x1, b.y1 - 5);
    }
  });

  tf.dispose(input);
  requestAnimationFrame(runDetection);
}

async function init() {
  await loadModel();
  await startVideo();
  runDetection();
}

init();
</script>
</body>
</html>
