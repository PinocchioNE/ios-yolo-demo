<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 目标检测</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .video-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        .video-wrapper {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            max-width: 640px;
        }
        #videoElement {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }
        #outputCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #007bff;
            border-radius: 8px;
            display: block;
        }
        .video-label {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            color: #333;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            min-width: 100px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-info {
            background-color: #17a2b8;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-card h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }
        .info-card p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .detection-details {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
        }
        .detection-details h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }
        .status.ready {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .model-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
            color: #856404;
        }
        .memory-info {
            background: #d1ecf1;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 12px;
            color: #0c5460;
        }
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            .info-panel {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            .controls {
                gap: 5px;
            }
            button {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>YOLOv8 目标检测</h1>
            <div class="model-info">
                xth_yolo_use_based_cellPhone
            </div>
            <div class="memory-info">
                <span id="memoryInfo">内存使用: 0MB</span> |
                <span id="tensorInfo">张量数量: 0</span>
            </div>
            <div id="status" class="status loading">正在初始化...</div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">开始检测</button>
            <button id="stopBtn" class="btn-secondary" disabled>停止检测</button>
            <button id="switchCameraBtn" class="btn-info" disabled>切换摄像头</button>
            <button id="clearMemoryBtn" class="btn-warning">清理内存</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="videoElement" autoplay muted playsinline></video>
                <div class="video-label">摄像头输入 (<span id="cameraType">前置</span>)</div>
            </div>
            <div class="video-wrapper">
                <canvas id="outputCanvas"></canvas>
                <div class="video-label">检测结果</div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h3>模型状态:</h3>
                <p id="modelStatus">未加载</p>
            </div>
            <div class="info-card">
                <h3>检测FPS:</h3>
                <p id="fpsDisplay">0</p>
            </div>
            <div class="info-card">
                <h3>处理时间:</h3>
                <p id="processingTime">0ms</p>
            </div>
            <div class="info-card">
                <h3>检测到的对象:</h3>
                <p id="objectCount">0</p>
            </div>
        </div>

        <div class="detection-details">
            <h3>检测详情:</h3>
            <div id="detectionList">暂无检测结果</div>
        </div>
    </div>

    <script>
        let model = null;
        let isDetecting = false;
        let video, canvas, ctx;
        let fps = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let currentStream = null;
        let facingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let detectionInterval = null;
        let memoryCheckInterval = null;
        let frameSkipCount = 0;
        const FRAME_SKIP = 1; // 改为每帧都处理，不跳帧

        // COCO数据集的80个类别名称
        const classNames = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        async function init() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('outputCanvas');
            ctx = canvas.getContext('2d');

            try {
                updateStatus('正在初始化摄像头...', 'loading');
                await setupCamera();
                await loadModel();
                setupEventListeners();
                startMemoryMonitoring();
                updateStatus('初始化完成，点击开始检测', 'ready');
            } catch (error) {
                console.error('初始化失败:', error);
                updateStatus('初始化失败: ' + error.message, 'error');
            }
        }

        async function setupCamera() {
            try {
                // 停止当前流
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 15, max: 30 } // 降低帧率减少负担
                    }
                };

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        // 设置canvas尺寸与video保持一致
                        const aspectRatio = video.videoWidth / video.videoHeight;
                        const maxWidth = 640;
                        const maxHeight = 480;

                        if (aspectRatio > maxWidth / maxHeight) {
                            canvas.width = maxWidth;
                            canvas.height = maxWidth / aspectRatio;
                        } else {
                            canvas.height = maxHeight;
                            canvas.width = maxHeight * aspectRatio;
                        }

                        // 更新摄像头类型显示
                        document.getElementById('cameraType').textContent =
                            facingMode === 'user' ? '前置' : '后置';

                        document.getElementById('switchCameraBtn').disabled = false;
                        resolve();
                    };
                });
            } catch (error) {
                console.error('摄像头设置失败:', error);
                throw error;
            }
        }

        async function switchCamera() {
            try {
                updateStatus('正在切换摄像头...', 'loading');
                facingMode = facingMode === 'user' ? 'environment' : 'user';
                await setupCamera();
                updateStatus(isDetecting ? '检测中...' : '摄像头切换完成', 'ready');
            } catch (error) {
                console.error('摄像头切换失败:', error);
                updateStatus('摄像头切换失败: ' + error.message, 'error');
                // 回退到原来的摄像头
                facingMode = facingMode === 'user' ? 'environment' : 'user';
            }
        }

        async function loadModel() {
            try {
                updateStatus('正在加载YOLO模型...', 'loading');
                document.getElementById('modelStatus').textContent = '加载中...';

                const modelUrl = 'https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json';
                model = await tf.loadGraphModel(modelUrl);

                // 预热模型
                const dummyInput = tf.zeros([1, 640, 640, 3]);
                const warmupResult = model.predict(dummyInput);
                warmupResult.dispose();
                dummyInput.dispose();

                document.getElementById('modelStatus').textContent = '已加载';
                console.log('模型加载成功');
            } catch (error) {
                document.getElementById('modelStatus').textContent = '加载失败';
                throw new Error('模型加载失败: ' + error.message);
            }
        }

        function setupEventListeners() {
            document.getElementById('startBtn').addEventListener('click', startDetection);
            document.getElementById('stopBtn').addEventListener('click', stopDetection);
            document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
            document.getElementById('clearMemoryBtn').addEventListener('click', clearMemory);

            // 页面隐藏时停止检测
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && isDetecting) {
                    stopDetection();
                }
            });

            // 页面卸载时清理资源
            window.addEventListener('beforeunload', cleanup);
        }

        function startDetection() {
            if (!model) {
                alert('模型未加载完成');
                return;
            }

            isDetecting = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateStatus('检测中...', 'ready');

            detectLoop();
        }

        function stopDetection() {
            isDetecting = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('检测已停止', 'ready');

            // 清理检测间隔
            if (detectionInterval) {
                clearTimeout(detectionInterval);
                detectionInterval = null;
            }
        }

        async function detectLoop() {
            if (!isDetecting) return;

            try {
                // 不跳帧，每帧都处理
                frameSkipCount++;
                if (frameSkipCount < FRAME_SKIP) {
                    detectionInterval = setTimeout(detectLoop, 16); // ~60fps显示频率
                    return;
                }
                frameSkipCount = 0;

                const startTime = performance.now();

                // 预处理图像
                const inputTensor = preprocessImage();

                // 模型推理
                const predictions = model.predict(inputTensor);

                // 后处理
                const detections = await postprocess(predictions);

                // 绘制结果
                drawResults(detections);

                // 更新性能指标
                const processingTime = performance.now() - startTime;
                updatePerformanceMetrics(processingTime, detections.length);

                // 立即清理内存
                inputTensor.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(tensor => tensor.dispose());
                } else {
                    predictions.dispose();
                }

                // 定期强制垃圾回收
                if (frameCount % 30 === 0) {
                    await tf.nextFrame();
                }

            } catch (error) {
                console.error('检测过程出错:', error);
                stopDetection();
                clearMemory();
                updateStatus('检测出错，已自动停止: ' + error.message, 'error');
            }

            // 提高处理频率
            if (isDetecting) {
                detectionInterval = setTimeout(detectLoop, 33); // 30fps处理频率
            }
        }

        function preprocessImage() {
            // 创建临时canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 640;
            tempCanvas.height = 640;

            // 居中裁剪并缩放到640x640
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const size = Math.min(videoWidth, videoHeight);
            const x = (videoWidth - size) / 2;
            const y = (videoHeight - size) / 2;

            tempCtx.drawImage(video, x, y, size, size, 0, 0, 640, 640);

            // 转换为tensor
            const imageData = tempCtx.getImageData(0, 0, 640, 640);
            return tf.browser.fromPixels(imageData)
                .expandDims(0)
                .div(255.0);
        }

        // 修复后的后处理函数
        async function postprocess(predictions) {
            const output = Array.isArray(predictions) ? predictions[0] : predictions;
            const outputData = await output.data();
            const outputShape = output.shape;

            const detections = [];

            // YOLOv8输出格式通常是 [1, 84, 8400] 或类似格式
            if (outputShape.length === 3) {
                const [batchSize, numClasses, numBoxes] = outputShape;

                // 转置数据：从 [1, 84, 8400] 到 [8400, 84]
                for (let i = 0; i < numBoxes; i++) {
                    // 提取坐标 (cx, cy, w, h)
                    const cx = outputData[i];
                    const cy = outputData[numBoxes + i];
                    const w = outputData[2 * numBoxes + i];
                    const h = outputData[3 * numBoxes + i];

                    // 找到最大类别概率
                    let maxClassScore = 0;
                    let classId = 0;

                    for (let j = 4; j < numClasses; j++) {
                        const classScore = outputData[j * numBoxes + i];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            classId = j - 4;
                        }
                    }

                    // 提高置信度阈值，减少误检
                    if (maxClassScore > 0.7) {
                        detections.push({
                            x: (cx - w / 2) / 640,
                            y: (cy - h / 2) / 640,
                            width: w / 640,
                            height: h / 640,
                            confidence: maxClassScore,
                            classId: classId,
                            className: classNames[classId] || `class_${classId}`
                        });
                    }
                }
            } else {
                // 备用处理方式
                const numDetections = Math.min(8400, Math.floor(outputData.length / 85));

                for (let i = 0; i < numDetections; i++) {
                    const offset = i * 85;
                    const cx = outputData[offset];
                    const cy = outputData[offset + 1];
                    const w = outputData[offset + 2];
                    const h = outputData[offset + 3];

                    let maxClassScore = 0;
                    let classId = 0;

                    for (let j = 0; j < 80; j++) {
                        const classScore = outputData[offset + 4 + j];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            classId = j;
                        }
                    }

                    if (maxClassScore > 0.7) {
                        detections.push({
                            x: (cx - w / 2) / 640,
                            y: (cy - h / 2) / 640,
                            width: w / 640,
                            height: h / 640,
                            confidence: maxClassScore,
                            classId: classId,
                            className: classNames[classId] || `class_${classId}`
                        });
                    }
                }
            }

            // 非极大值抑制 (NMS)
            return applyNMS(detections, 0.4);
        }

        // 非极大值抑制函数
        function applyNMS(detections, iouThreshold) {
            detections.sort((a, b) => b.confidence - a.confidence);

            const keep = [];
            const suppressed = new Set();

            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;

                keep.push(detections[i]);

                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;

                    const iou = calculateIoU(detections[i], detections[j]);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }

            return keep.slice(0, 20); // 限制最大检测数量
        }

        // 计算IoU
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

            if (x2 <= x1 || y2 <= y1) return 0;

            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;

            return intersection / union;
        }

        function drawResults(detections) {
            // 清空canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制视频帧到canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 绘制检测框
            detections.forEach((detection) => {
                const x = detection.x * canvas.width;
                const y = detection.y * canvas.height;
                const width = detection.width * canvas.width;
                const height = detection.height * canvas.height;

                // 绘制检测框
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);

                // 绘制标签
                const label = `${detection.className} ${(detection.confidence * 100).toFixed(1)}%`;
                ctx.fillStyle = '#FF0000';
                ctx.font = '14px Arial';

                // 标签背景
                const textWidth = ctx.measureText(label).width;
                ctx.fillRect(x, y - 20, textWidth + 8, 20);

                // 标签文字
                ctx.fillStyle = 'white';
                ctx.fillText(label, x + 4, y - 4);
            });

            updateDetectionDetails(detections);
        }

        function updateDetectionDetails(detections) {
            const detectionList = document.getElementById('detectionList');

            if (detections.length === 0) {
                detectionList.innerHTML = '暂无检测结果';
                return;
            }

            const detectionHTML = detections.map(detection =>
                `${detection.className} (${(detection.confidence * 100).toFixed(1)}%)`
            ).join(', ');

            detectionList.innerHTML = detectionHTML;
        }

        function updatePerformanceMetrics(processingTime, objectCount) {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
            }

            document.getElementById('fpsDisplay').textContent = fps;
            document.getElementById('processingTime').textContent = `${processingTime.toFixed(1)}ms`;
            document.getElementById('objectCount').textContent = objectCount;
        }

        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        // 内存管理函数
        function clearMemory() {
            try {
                // 强制垃圾回收
                if (window.gc) {
                    window.gc();
                }

                // TensorFlow.js 内存清理
                tf.disposeVariables();
                tf.engine().startScope();
                tf.engine().endScope();

                console.log('内存清理完成');
                updateStatus('内存清理完成', 'ready');
            } catch (error) {
                console.error('内存清理失败:', error);
            }
        }

        function startMemoryMonitoring() {
            memoryCheckInterval = setInterval(() => {
                const memInfo = tf.memory();
                const memoryMB = (memInfo.numBytes / 1024 / 1024).toFixed(1);

                document.getElementById('memoryInfo').textContent = `内存使用: ${memoryMB}MB`;
                document.getElementById('tensorInfo').textContent = `张量数量: ${memInfo.numTensors}`;

                // 内存使用过高时自动清理
                if (memInfo.numBytes > 500 * 1024 * 1024) { // 500MB
                    console.warn('内存使用过高，自动清理');
                    clearMemory();
                }
            }, 2000);
        }

        function cleanup() {
            stopDetection();

            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            if (memoryCheckInterval) {
                clearInterval(memoryCheckInterval);
            }

            clearMemory();
        }

        // 初始化
        init();
    </script>
</body>
</html>
