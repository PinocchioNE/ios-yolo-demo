<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 TensorFlow.js 目标检测</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .video-wrapper {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        #videoElement {
            width: 480px;
            height: 360px;
            object-fit: cover;
        }
        #outputCanvas {
            width: 480px;
            height: 360px;
            border: 2px solid #007bff;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-card h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }
        .info-card p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .detection-details {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .detection-details h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        .detection-item {
            background: white;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #4caf50;
        }
        .controls-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .control-group label {
            min-width: 120px;
            font-weight: bold;
        }
        input[type="range"] {
            flex: 1;
            max-width: 200px;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }
        .status.ready {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>YOLOv8 TensorFlow.js 实时目标检测</h1>
            <div id="status" class="status loading">正在初始化...</div>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <label>置信度阈值:</label>
                <input type="range" id="confidenceSlider" min="0.1" max="0.9" step="0.05" value="0.5">
                <span id="confidenceValue">0.5</span>
            </div>
            <div class="control-group">
                <label>NMS阈值:</label>
                <input type="range" id="nmsSlider" min="0.1" max="0.9" step="0.05" value="0.4">
                <span id="nmsValue">0.4</span>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">开始检测</button>
            <button id="stopBtn" class="btn-secondary" disabled>停止检测</button>
            <button id="switchCameraBtn" class="btn-secondary">切换摄像头</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="videoElement" autoplay muted playsinline></video>
                <div style="text-align: center; margin-top: 10px;">摄像头输入</div>
            </div>
            <div class="video-wrapper">
                <canvas id="outputCanvas"></canvas>
                <div style="text-align: center; margin-top: 10px;">检测结果</div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h3>模型状态:</h3>
                <p id="modelStatus">未加载</p>
            </div>
            <div class="info-card">
                <h3>检测FPS:</h3>
                <p id="fpsDisplay">0</p>
            </div>
            <div class="info-card">
                <h3>处理时间:</h3>
                <p id="processingTime">0ms</p>
            </div>
            <div class="info-card">
                <h3>检测到的对象:</h3>
                <p id="objectCount">0</p>
            </div>
        </div>

        <div class="detection-details">
            <h3>检测详情:</h3>
            <div id="detectionList">暂无检测结果</div>
        </div>
    </div>

    <script>
        class YOLODetector {
            constructor() {
                this.model = null;
                this.isDetecting = false;
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('outputCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentStream = null;
                this.currentCameraIndex = 0;
                this.cameras = [];
                this.animationId = null;

                // 性能监控
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();

                // 检测参数
                this.confidenceThreshold = 0.5;
                this.nmsThreshold = 0.4;

                // COCO类别名称
                this.classNames = [
                    'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
                    'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
                    'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
                    'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
                    'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
                    'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
                    'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
                    'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
                    'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
                    'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
                ];

                this.init();
            }

            async init() {
                try {
                    this.updateStatus('正在初始化摄像头...', 'loading');
                    await this.setupCamera();
                    await this.loadModel();
                    this.setupEventListeners();
                    this.updateStatus('初始化完成，点击开始检测', 'ready');
                } catch (error) {
                    console.error('初始化失败:', error);
                    this.updateStatus('初始化失败: ' + error.message, 'error');
                }
            }

            async setupCamera() {
                try {
                    // 获取所有摄像头设备
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.cameras = devices.filter(device => device.kind === 'videoinput');

                    if (this.cameras.length === 0) {
                        throw new Error('未找到摄像头设备');
                    }

                    await this.switchCamera(this.currentCameraIndex);
                } catch (error) {
                    throw new Error('摄像头初始化失败: ' + error.message);
                }
            }

            async switchCamera(index) {
                try {
                    // 停止当前流
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                    }

                    const deviceId = this.cameras[index]?.deviceId;
                    const constraints = {
                        video: {
                            deviceId: deviceId ? { exact: deviceId } : undefined,
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            frameRate: { ideal: 30 }
                        }
                    };

                    this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.currentStream;

                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            // 设置canvas尺寸
                            this.canvas.width = 640;
                            this.canvas.height = 640;
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('切换摄像头失败: ' + error.message);
                }
            }

            async loadModel() {
                try {
                    this.updateStatus('正在加载YOLO模型...', 'loading');
                    document.getElementById('modelStatus').textContent = '加载中...';

                    // 替换为你的模型URL
                    const modelUrl = 'https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json';

                    this.model = await tf.loadLayersModel(modelUrl);

                    // 预热模型
                    const dummyInput = tf.zeros([1, 640, 640, 3]);
                    const warmupResult = this.model.predict(dummyInput);
                    warmupResult.dispose();
                    dummyInput.dispose();

                    document.getElementById('modelStatus').textContent = '已加载';
                    console.log('模型加载成功');
                } catch (error) {
                    document.getElementById('modelStatus').textContent = '加载失败';
                    throw new Error('模型加载失败: ' + error.message);
                }
            }

            setupEventListeners() {
                // 开始/停止按钮
                document.getElementById('startBtn').addEventListener('click', () => this.startDetection());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopDetection());

                // 切换摄像头
                document.getElementById('switchCameraBtn').addEventListener('click', () => {
                    this.currentCameraIndex = (this.currentCameraIndex + 1) % this.cameras.length;
                    this.switchCamera(this.currentCameraIndex);
                });

                // 参数控制
                const confidenceSlider = document.getElementById('confidenceSlider');
                const nmsSlider = document.getElementById('nmsSlider');

                confidenceSlider.addEventListener('input', (e) => {
                    this.confidenceThreshold = parseFloat(e.target.value);
                    document.getElementById('confidenceValue').textContent = e.target.value;
                });

                nmsSlider.addEventListener('input', (e) => {
                    this.nmsThreshold = parseFloat(e.target.value);
                    document.getElementById('nmsValue').textContent = e.target.value;
                });
            }

            startDetection() {
                if (!this.model) {
                    alert('模型未加载完成');
                    return;
                }

                this.isDetecting = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                this.updateStatus('检测中...', 'ready');

                this.detectLoop();
            }

            stopDetection() {
                this.isDetecting = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                this.updateStatus('检测已停止', 'ready');

                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            async detectLoop() {
                if (!this.isDetecting) return;

                try {
                    const startTime = performance.now();

                    // 预处理图像
                    const inputTensor = this.preprocessImage();

                    // 模型推理
                    const predictions = this.model.predict(inputTensor);

                    // 后处理
                    const detections = await this.postprocess(predictions);

                    // 绘制结果
                    this.drawDetections(detections);

                    // 更新性能指标
                    const processingTime = performance.now() - startTime;
                    this.updatePerformanceMetrics(processingTime, detections.length);

                    // 清理内存
                    inputTensor.dispose();
                    if (Array.isArray(predictions)) {
                        predictions.forEach(tensor => tensor.dispose());
                    } else {
                        predictions.dispose();
                    }

                } catch (error) {
                    console.error('检测过程出错:', error);
                    this.updateStatus('检测出错: ' + error.message, 'error');
                }

                // 继续下一帧
                this.animationId = requestAnimationFrame(() => this.detectLoop());
            }

            preprocessImage() {
                // 创建临时canvas进行图像预处理
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = 640;
                tempCanvas.height = 640;

                // 计算居中裁剪参数
                const videoWidth = this.video.videoWidth;
                const videoHeight = this.video.videoHeight;
                const aspectRatio = videoWidth / videoHeight;

                let sourceX = 0, sourceY = 0, sourceWidth = videoWidth, sourceHeight = videoHeight;

                if (aspectRatio > 1) {
                    // 视频更宽，裁剪左右
                    sourceWidth = videoHeight;
                    sourceX = (videoWidth - sourceWidth) / 2;
                } else {
                    // 视频更高，裁剪上下
                    sourceHeight = videoWidth;
                    sourceY = (videoHeight - sourceHeight) / 2;
                }

                // 绘制裁剪后的图像
                tempCtx.drawImage(
                    this.video,
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    0, 0, 640, 640
                );

                // 转换为tensor
                const imageData = tempCtx.getImageData(0, 0, 640, 640);
                const tensor = tf.browser.fromPixels(imageData)
                    .expandDims(0)
                    .div(255.0);

                return tensor;
            }

            async postprocess(predictions) {
                // 获取预测结果
                const output = Array.isArray(predictions) ? predictions[0] : predictions;
                const outputData = await output.data();

                const detections = [];
                const numDetections = outputData.length / 85; // 假设输出格式为 [x, y, w, h, conf, ...classes]

                for (let i = 0; i < numDetections; i++) {
                    const offset = i * 85;
                    const confidence = outputData[offset + 4];

                    if (confidence > this.confidenceThreshold) {
                        // 找到最高置信度的类别
                        let maxClassScore = 0;
                        let classId = 0;

                        for (let j = 0; j < 80; j++) {
                            const classScore = outputData[offset + 5 + j];
                            if (classScore > maxClassScore) {
                                maxClassScore = classScore;
                                classId = j;
                            }
                        }

                        const finalScore = confidence * maxClassScore;

                        if (finalScore > this.confidenceThreshold) {
                            const x = outputData[offset];
                            const y = outputData[offset + 1];
                            const w = outputData[offset + 2];
                            const h = outputData[offset + 3];

                            detections.push({
                                x: x - w / 2,
                                y: y - h / 2,
                                width: w,
                                height: h,
                                confidence: finalScore,
                                classId: classId,
                                className: this.classNames[classId] || `class_${classId}`
                            });
                        }
                    }
                }

                // 应用NMS
                return this.applyNMS(detections);
            }

            applyNMS(detections) {
                // 按置信度排序
                detections.sort((a, b) => b.confidence - a.confidence);

                const keep = [];
                const suppressed = new Set();

                for (let i = 0; i < detections.length; i++) {
                    if (suppressed.has(i)) continue;

                    keep.push(detections[i]);

                    for (let j = i + 1; j < detections.length; j++) {
                        if (suppressed.has(j)) continue;

                        const iou = this.calculateIoU(detections[i], detections[j]);
                        if (iou > this.nmsThreshold && detections[i].classId === detections[j].classId) {
                            suppressed.add(j);
                        }
                    }
                }

                return keep;
            }

            calculateIoU(box1, box2) {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

                if (x2 <= x1 || y2 <= y1) return 0;

                const intersection = (x2 - x1) * (y2 - y1);
                const area1 = box1.width * box1.height;
                const area2 = box2.width * box2.height;
                const union = area1 + area2 - intersection;

                return intersection / union;
            }

            drawDetections(detections) {
                // 清空canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制视频帧
                const videoWidth = this.video.videoWidth;
                const videoHeight = this.video.videoHeight;
                const aspectRatio = videoWidth / videoHeight;

                let sourceX = 0, sourceY = 0, sourceWidth = videoWidth, sourceHeight = videoHeight;

                if (aspectRatio > 1) {
                    sourceWidth = videoHeight;
                    sourceX = (videoWidth - sourceWidth) / 2;
                } else {
                    sourceHeight = videoWidth;
                    sourceY = (videoHeight - sourceHeight) / 2;
                }

                this.ctx.drawImage(
                    this.video,
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    0, 0, 640, 640
                );

                // 绘制检测框
                detections.forEach((detection, index) => {
                    const x = detection.x * 640;
                    const y = detection.y * 640;
                    const width = detection.width * 640;
                    const height = detection.height * 640;

                    // 设置颜色
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
                    const color = colors[detection.classId % colors.length];

                    // 绘制边框
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x, y, width, height);

                    // 绘制标签背景
                    const label = `${detection.className} ${(detection.confidence * 100).toFixed(1)}%`;
                    this.ctx.font = '16px Arial';
                    const textMetrics = this.ctx.measureText(label);
                    const textWidth = textMetrics.width;
                    const textHeight = 20;

                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(x, y - textHeight - 4, textWidth + 8, textHeight + 4);

                    // 绘制标签文字
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillText(label, x + 4, y - 8);
                });
            }

            updatePerformanceMetrics(processingTime, objectCount) {
                // 更新FPS
                this.frameCount++;
                const currentTime = performance.now();
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }

                // 更新UI
                document.getElementById('fpsDisplay').textContent = this.fps;
                document.getElementById('processingTime').textContent = `${processingTime.toFixed(1)}ms`;
                document.getElementById('objectCount').textContent = objectCount;
            }

            updateStatus(message, type) {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }
        }

        // 初始化检测器
        const detector = new YOLODetector();
    </script>
</body>
</html>
