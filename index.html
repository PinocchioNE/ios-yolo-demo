<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YOLOv8 TF.js Demo</title>
  <style>
    video, canvas { border: 1px solid black; }
    .container { display: flex; gap: 20px; }
    .controls { margin: 10px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
</head>
<body>
  <h2>YOLOv8 TF.js Demo</h2>
  <div class="controls">
    <button id="switchBtn">切换摄像头</button>
    <span>置信度阈值: <input type="range" id="confSlider" min="0.1" max="0.9" step="0.05" value="0.25"> <span id="confValue">0.25</span></span>
  </div>
  <div class="container">
    <video id="video" autoplay playsinline width="640" height="480"></video>
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>
  <div id="status">加载中...</div>

  <script>
    // COCO数据集类别名称
    const classNames = [
      'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
      'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
      'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
      'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
      'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
      'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
      'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
      'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
      'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
      'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
    ];

    let confThreshold = 0.25;
    const iouThreshold = 0.45;

    window.onload = async () => {
      let model;
      let video = document.getElementById('video');
      let canvas = document.getElementById('canvas');
      let ctx = canvas.getContext('2d');
      let useFrontCamera = false;
      let currentStream;
      let isDetecting = false;
      
      const statusDiv = document.getElementById('status');
      const confSlider = document.getElementById('confSlider');
      const confValue = document.getElementById('confValue');

      // 置信度滑块事件
      confSlider.addEventListener('input', (e) => {
        confThreshold = parseFloat(e.target.value);
        confValue.textContent = confThreshold.toFixed(2);
      });

      // 加载模型
      async function loadModel() {
        try {
          statusDiv.textContent = '正在加载模型...';
          model = await tf.loadGraphModel('https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json');
          console.log('模型加载完成');
          console.log('模型输入形状:', model.inputs[0].shape);
          statusDiv.textContent = '模型加载完成，正在启动摄像头...';
        } catch (error) {
          console.error('模型加载失败:', error);
          statusDiv.textContent = '模型加载失败: ' + error.message;
        }
      }

      // 启动摄像头
      async function startCamera() {
        try {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }
          
          const constraints = {
            audio: false,
            video: {
              facingMode: useFrontCamera ? 'user' : 'environment',
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
          };
          
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = currentStream;

          video.onloadedmetadata = () => {
            video.play();
            statusDiv.textContent = '检测中...';
            if (model && !isDetecting) {
              detectFrame();
            }
          };
        } catch (error) {
          console.error('摄像头启动失败:', error);
          statusDiv.textContent = '摄像头启动失败: ' + error.message;
        }
      }

      // 切换摄像头
      document.getElementById('switchBtn').addEventListener('click', () => {
        useFrontCamera = !useFrontCamera;
        startCamera();
      });

      // 绘制检测框
      function drawBoxes(boxes) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制视频帧
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // 绘制检测框
        boxes.forEach(box => {
          const [x1, y1, x2, y2, score, classId] = box;
          const className = classNames[classId] || `Class ${classId}`;
          
          // 绘制边框
          ctx.strokeStyle = '#FF0000';
          ctx.lineWidth = 2;
          ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
          
          // 绘制标签背景
          const label = `${className} ${(score * 100).toFixed(1)}%`;
          ctx.font = '14px Arial';
          const textWidth = ctx.measureText(label).width;
          const textHeight = 20;
          
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(x1, y1 - textHeight, textWidth + 8, textHeight);
          
          // 绘制标签文字
          ctx.fillStyle = '#FFFFFF';
          ctx.fillText(label, x1 + 4, y1 - 6);
        });
      }

      // 处理模型输出
      async function processOutput(predictions) {
        try {
          // 获取预测数据
          let output = predictions;
          
          // 检查输出形状并进行必要的转换
          console.log('原始输出形状:', output.shape);
          
          // 如果输出是 [1, 84, 8400] 格式，转换为 [1, 8400, 84]
          if (output.shape.length === 3 && output.shape[1] === 84) {
            output = output.transpose([0, 2, 1]);
          }
          
          const data = await output.data();
          const numDetections = output.shape[1]; // 通常是8400
          const numClasses = output.shape[2] - 5; // 减去x,y,w,h,objectness
          
          console.log(`处理 ${numDetections} 个检测结果，${numClasses} 个类别`);
          
          const boxes = [];
          const scores = [];
          const classIds = [];
          
          // 解析每个检测结果
          for (let i = 0; i < numDetections; i++) {
            const offset = i * (numClasses + 5);
            
            // 获取边界框坐标 (中心点格式)
            const centerX = data[offset];
            const centerY = data[offset + 1];
            const width = data[offset + 2];
            const height = data[offset + 3];
            const objectness = data[offset + 4];
            
            // 获取类别概率
            const classProbs = [];
            for (let j = 0; j < numClasses; j++) {
              classProbs.push(data[offset + 5 + j]);
            }
            
            // 找到最高概率的类别
            const maxClassProb = Math.max(...classProbs);
            const classId = classProbs.indexOf(maxClassProb);
            
            // 计算最终置信度
            const confidence = objectness * maxClassProb;
            
            // 过滤低置信度检测
            if (confidence > confThreshold) {
              // 转换为左上角坐标格式，并缩放到画布尺寸
              const x1 = Math.max(0, (centerX - width / 2) * canvas.width);
              const y1 = Math.max(0, (centerY - height / 2) * canvas.height);
              const x2 = Math.min(canvas.width, (centerX + width / 2) * canvas.width);
              const y2 = Math.min(canvas.height, (centerY + height / 2) * canvas.height);
              
              boxes.push([y1, x1, y2, x2]); // NMS需要[y1,x1,y2,x2]格式
              scores.push(confidence);
              classIds.push(classId);
            }
          }
          
          console.log(`过滤后剩余 ${boxes.length} 个检测结果`);
          
          if (boxes.length === 0) {
            return [];
          }
          
          // 应用非极大值抑制
          const boxesTensor = tf.tensor2d(boxes);
          const scoresTensor = tf.tensor1d(scores);
          
          const selectedIndices = await tf.image.nonMaxSuppressionAsync(
            boxesTensor,
            scoresTensor,
            50, // 最大检测数量
            iouThreshold,
            confThreshold
          );
          
          const selectedIndicesArray = await selectedIndices.data();
          
          // 构建最终结果
          const finalBoxes = [];
          for (let i = 0; i < selectedIndicesArray.length; i++) {
            const idx = selectedIndicesArray[i];
            const box = boxes[idx];
            finalBoxes.push([
              box[1], // x1
              box[0], // y1
              box[3], // x2
              box[2], // y2
              scores[idx],
              classIds[idx]
            ]);
          }
          
          // 清理张量
          boxesTensor.dispose();
          scoresTensor.dispose();
          selectedIndices.dispose();
          
          console.log(`NMS后剩余 ${finalBoxes.length} 个检测结果`);
          return finalBoxes;
          
        } catch (error) {
          console.error('处理输出时出错:', error);
          return [];
        }
      }

      // 检测帧
      async function detectFrame() {
        if (!model || !video.videoWidth || isDetecting) {
          requestAnimationFrame(detectFrame);
          return;
        }
        
        isDetecting = true;
        
        try {
          // 开始TensorFlow作用域
          const result = tf.tidy(() => {
            // 从视频获取输入
            const input = tf.browser.fromPixels(video)
              .resizeBilinear([640, 640]) // 调整到模型输入尺寸
              .expandDims(0) // 添加批次维度
              .toFloat() // 转换为浮点数
              .div(255.0); // 归一化到[0,1]
            
            console.log('输入张量形状:', input.shape);
            return input;
          });
          
          // 执行推理
          const predictions = await model.executeAsync(result);
          
          // 处理输出
          const boxes = await processOutput(predictions);
          
          // 绘制结果
          drawBoxes(boxes);
          
          // 清理张量
          result.dispose();
          if (Array.isArray(predictions)) {
            predictions.forEach(p => p.dispose());
          } else {
            predictions.dispose();
          }
          
        } catch (error) {
          console.error('检测过程中出错:', error);
          statusDiv.textContent = '检测出错: ' + error.message;
        }
        
        isDetecting = false;
        requestAnimationFrame(detectFrame);
      }

      // 初始化
      try {
        await loadModel();
        await startCamera();
      } catch (error) {
        console.error('初始化失败:', error);
        statusDiv.textContent = '初始化失败: ' + error.message;
      }
    };
  </script>
</body>
</html>
