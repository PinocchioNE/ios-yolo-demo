<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 TensorFlow.js 目标检测</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .video-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        .video-wrapper {
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            max-width: 640px;
        }
        #videoElement {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }
        #outputCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #007bff;
            border-radius: 8px;
            display: block;
        }
        .video-label {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            color: #333;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-card h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }
        .info-card p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .detection-details {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
        }
        .detection-details h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }
        .status.ready {
            background-color: #d4edda;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .model-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
            color: #856404;
        }
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            .info-panel {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>YOLOv8 TensorFlow.js 实时目标检测</h1>
            <div class="model-info">
                xth_yolo_phone_test
            </div>
            <div id="status" class="status loading">正在初始化...</div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn-primary">开始检测</button>
            <button id="stopBtn" class="btn-secondary" disabled>停止检测</button>
        </div>

        <div class="video-container">
            <div class="video-wrapper">
                <video id="videoElement" autoplay muted playsinline></video>
                <div class="video-label">摄像头输入</div>
            </div>
            <div class="video-wrapper">
                <canvas id="outputCanvas"></canvas>
                <div class="video-label">检测结果</div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h3>模型状态:</h3>
                <p id="modelStatus">未加载</p>
            </div>
            <div class="info-card">
                <h3>检测FPS:</h3>
                <p id="fpsDisplay">0</p>
            </div>
            <div class="info-card">
                <h3>处理时间:</h3>
                <p id="processingTime">0ms</p>
            </div>
            <div class="info-card">
                <h3>检测到的对象:</h3>
                <p id="objectCount">0</p>
            </div>
        </div>

        <div class="detection-details">
            <h3>检测详情:</h3>
            <div id="detectionList">暂无检测结果</div>
        </div>
    </div>

    <script>
        let model = null;
        let isDetecting = false;
        let video, canvas, ctx;
        let fps = 0;
        let frameCount = 0;
        let lastTime = performance.now();

        // COCO数据集的80个类别名称
        const classNames = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        async function init() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('outputCanvas');
            ctx = canvas.getContext('2d');

            try {
                updateStatus('正在初始化摄像头...', 'loading');
                await setupCamera();
                await loadModel();
                setupEventListeners();
                updateStatus('初始化完成，点击开始检测', 'ready');
            } catch (error) {
                console.error('初始化失败:', error);
                updateStatus('初始化失败: ' + error.message, 'error');
            }
        }

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                }
            });

            video.srcObject = stream;

            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    // 设置canvas尺寸与video保持一致
                    const aspectRatio = video.videoWidth / video.videoHeight;
                    const maxWidth = 640;
                    const maxHeight = 480;
                    
                    if (aspectRatio > maxWidth / maxHeight) {
                        canvas.width = maxWidth;
                        canvas.height = maxWidth / aspectRatio;
                    } else {
                        canvas.height = maxHeight;
                        canvas.width = maxHeight * aspectRatio;
                    }
                    resolve();
                };
            });
        }

        async function loadModel() {
            try {
                updateStatus('正在加载YOLO模型...', 'loading');
                document.getElementById('modelStatus').textContent = '加载中...';

                // 替换为你的实际模型URL
                const modelUrl = 'https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json';
                model = await tf.loadGraphModel(modelUrl);

                // 预热模型
                const dummyInput = tf.zeros([1, 640, 640, 3]);
                const warmupResult = model.predict(dummyInput);
                warmupResult.dispose();
                dummyInput.dispose();

                document.getElementById('modelStatus').textContent = '已加载';
                console.log('模型加载成功');
            } catch (error) {
                document.getElementById('modelStatus').textContent = '加载失败';
                throw new Error('模型加载失败: ' + error.message);
            }
        }

        function setupEventListeners() {
            document.getElementById('startBtn').addEventListener('click', startDetection);
            document.getElementById('stopBtn').addEventListener('click', stopDetection);
        }

        function startDetection() {
            if (!model) {
                alert('模型未加载完成');
                return;
            }

            isDetecting = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateStatus('检测中...', 'ready');

            detectLoop();
        }

        function stopDetection() {
            isDetecting = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus('检测已停止', 'ready');
        }

        async function detectLoop() {
            if (!isDetecting) return;

            try {
                const startTime = performance.now();

                // 预处理图像
                const inputTensor = preprocessImage();

                // 模型推理
                const predictions = model.predict(inputTensor);

                // 后处理
                const detections = await postprocess(predictions);

                // 绘制结果
                drawResults(detections);

                // 更新性能指标
                const processingTime = performance.now() - startTime;
                updatePerformanceMetrics(processingTime, detections.length);

                // 清理内存
                inputTensor.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(tensor => tensor.dispose());
                } else {
                    predictions.dispose();
                }

            } catch (error) {
                console.error('检测过程出错:', error);
            }

            requestAnimationFrame(detectLoop);
        }

        function preprocessImage() {
            // 创建临时canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 640;
            tempCanvas.height = 640;

            // 居中裁剪并缩放到640x640
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const size = Math.min(videoWidth, videoHeight);
            const x = (videoWidth - size) / 2;
            const y = (videoHeight - size) / 2;

            tempCtx.drawImage(video, x, y, size, size, 0, 0, 640, 640);

            // 转换为tensor
            const imageData = tempCtx.getImageData(0, 0, 640, 640);
            return tf.browser.fromPixels(imageData)
                .expandDims(0)
                .div(255.0);
        }

        // 修复后的后处理函数
        async function postprocess(predictions) {
            const output = Array.isArray(predictions) ? predictions[0] : predictions;
            const outputData = await output.data();
            const outputShape = output.shape;
            
            console.log('模型输出形状:', outputShape);
            console.log('输出数据长度:', outputData.length);
            
            const detections = [];
            
            // YOLOv8输出格式通常是 [1, 84, 8400] 或类似格式
            // 其中84 = 4(坐标) + 80(类别)
            if (outputShape.length === 3) {
                const [batchSize, numClasses, numBoxes] = outputShape;
                
                // 转置数据：从 [1, 84, 8400] 到 [8400, 84]
                for (let i = 0; i < numBoxes; i++) {
                    // 提取坐标 (cx, cy, w, h)
                    const cx = outputData[i];
                    const cy = outputData[numBoxes + i];
                    const w = outputData[2 * numBoxes + i];
                    const h = outputData[3 * numBoxes + i];
                    
                    // 找到最大类别概率
                    let maxClassScore = 0;
                    let classId = 0;
                    
                    for (let j = 4; j < numClasses; j++) {
                        const classScore = outputData[j * numBoxes + i];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            classId = j - 4; // 减去坐标的4个维度
                        }
                    }
                    
                    // 只保留高置信度的检测
                    if (maxClassScore > 0.6) {
                        detections.push({
                            x: (cx - w / 2) / 640, // 转换为归一化坐标
                            y: (cy - h / 2) / 640,
                            width: w / 640,
                            height: h / 640,
                            confidence: maxClassScore,
                            classId: classId,
                            className: classNames[classId] || `class_${classId}`
                        });
                    }
                }
            } else {
                // 备用处理方式：假设是扁平化的格式
                const numDetections = Math.min(8400, Math.floor(outputData.length / 85));
                
                for (let i = 0; i < numDetections; i++) {
                    const offset = i * 85;
                    const cx = outputData[offset];
                    const cy = outputData[offset + 1];
                    const w = outputData[offset + 2];
                    const h = outputData[offset + 3];
                    
                    let maxClassScore = 0;
                    let classId = 0;
                    
                    for (let j = 0; j < 80; j++) {
                        const classScore = outputData[offset + 4 + j];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            classId = j;
                        }
                    }
                    
                    if (maxClassScore > 0.6) {
                        detections.push({
                            x: (cx - w / 2) / 640,
                            y: (cy - h / 2) / 640,
                            width: w / 640,
                            height: h / 640,
                            confidence: maxClassScore,
                            classId: classId,
                            className: classNames[classId] || `class_${classId}`
                        });
                    }
                }
            }
            
            // 非极大值抑制 (NMS)
            return applyNMS(detections, 0.4);
        }
        
        // 非极大值抑制函数
        function applyNMS(detections, iouThreshold) {
            // 按置信度排序
            detections.sort((a, b) => b.confidence - a.confidence);
            
            const keep = [];
            const suppressed = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;
                
                keep.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;
                    
                    const iou = calculateIoU(detections[i], detections[j]);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }
            
            return keep;
        }
        
        // 计算IoU
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
            
            if (x2 <= x1 || y2 <= y1) return 0;
            
            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }

        function drawResults(detections) {
            // 清空canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制视频帧到canvas，保持原始比例
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 绘制检测框
            detections.forEach((detection) => {
                // 将归一化坐标转换为canvas坐标
                const x = detection.x * canvas.width;
                const y = detection.y * canvas.height;
                const width = detection.width * canvas.width;
                const height = detection.height * canvas.height;

                // 绘制检测框
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);

                // 绘制标签
                const label = `${detection.className} ${(detection.confidence * 100).toFixed(1)}%`;
                ctx.fillStyle = '#FF0000';
                ctx.font = '16px Arial';

                // 标签背景
                const textWidth = ctx.measureText(label).width;
                ctx.fillRect(x, y - 25, textWidth + 10, 25);

                // 标签文字
                ctx.fillStyle = 'white';
                ctx.fillText(label, x + 5, y - 5);
            });

            // 更新检测详情
            updateDetectionDetails(detections);
        }

        function updateDetectionDetails(detections) {
            const detectionList = document.getElementById('detectionList');

            if (detections.length === 0) {
                detectionList.innerHTML = '暂无检测结果';
                return;
            }

            const detectionHTML = detections.map(detection =>
                `${detection.className} (${(detection.confidence * 100).toFixed(1)}%)`
            ).join(', ');

            detectionList.innerHTML = detectionHTML;
        }

        function updatePerformanceMetrics(processingTime, objectCount) {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
            }

            document.getElementById('fpsDisplay').textContent = fps;
            document.getElementById('processingTime').textContent = `${processingTime.toFixed(1)}ms`;
            document.getElementById('objectCount').textContent = objectCount;
        }

        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        // 初始化
        init();
    </script>
</body>
</html>
