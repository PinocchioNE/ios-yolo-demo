<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YOLOv8 TF.js Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
  <style>
    video, canvas {
      width: 320px;
      height: 240px;
      border: 1px solid #333;
      margin: 5px;
    }
  </style>
</head>
<body>
  <h2>YOLOv8 TF.js Demo</h2>
  <button id="switchBtn">切换前/后摄像头</button>
  <div>
    <video id="video" autoplay muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let model;
    let useFrontCamera = true;
    let stream;

    async function loadModel() {
      model = await tf.loadGraphModel('https://pinocchione.github.io/ios-yolo-demo/yolov8n_web_model/model.json');
      console.log('Model loaded:', model);
      startCamera();
    }

    async function startCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: useFrontCamera ? 'user' : 'environment' }
      });
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        runDetection();
      };
    }

    document.getElementById('switchBtn').addEventListener('click', () => {
      useFrontCamera = !useFrontCamera;
      startCamera();
    });

    async function runDetection() {
      if (!model) return;
      tf.engine().startScope();

      const videoTensor = tf.browser.fromPixels(video).expandDims(0).toFloat().div(255);
      const predictions = await model.executeAsync(videoTensor);

      // predictions 是对象或数组，根据模型输出调整
      // 这里假设 predictions 是数组，取第一个 tensor
      let boxes = [];
      if (Array.isArray(predictions)) {
        boxes = await predictions[0].array();
      } else if (predictions instanceof tf.Tensor) {
        boxes = await predictions.array();
      } else if (typeof predictions === 'object') {
        // TF.js graph model 输出对象时
        const key = Object.keys(predictions)[0];
        boxes = await predictions[key].array();
      }

      // 清空 canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // 绘制预测框
      boxes.forEach(box => {
        // 假设 box = [x1, y1, x2, y2, score, class]
        const [x1, y1, x2, y2, score, cls] = box;
        if (score > 0.3) { // 阈值
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.strokeRect(x1 * canvas.width, y1 * canvas.height, (x2 - x1) * canvas.width, (y2 - y1) * canvas.height);
          ctx.fillStyle = 'red';
          ctx.fillText(`cls:${cls} ${score.toFixed(2)}`, x1 * canvas.width, y1 * canvas.height - 2);
        }
      });

      console.log('Predictions:', boxes);
      tf.engine().endScope();
      requestAnimationFrame(runDetection);
    }

    loadModel();
  </script>
</body>
</html>
